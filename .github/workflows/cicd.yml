name: CICD
on: push
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up JDK 11
      uses: actions/setup-java@v4
      with:
        java-version: '17'
        distribution: 'temurin'

    - name: Cache Maven dependencies
      uses: actions/cache@v4
      with:
        path: ~/.m2/repository
        key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
        restore-keys: |
          ${{ runner.os }}-maven-
          
    - name: Build with Maven
      working-directory: ./initial
      run: mvn --batch-mode clean test package

    - name: Upload build artifact
      uses: actions/upload-artifact@v4
      with:
       name: app-jar
       path: initial/target/*.jar
  
  deploy:
    needs: build
    runs-on: ubuntu-latest
    
    env:
      AWS_REGION: ${{ secrets.AWS_REGION }}
      ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
      IMAGE_TAG: ${{ github.sha }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Download JAR artifact
      uses: actions/download-artifact@v4
      with:
        name: app-jar
        path: initial/target
        
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        # role-to-assume: arn:aws:iam::557690581666:role/GitHubActionsEKSRole
        # role-session-name: GitHubActions
        # audience: sts.amazonaws.com

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v1

    - name: Build Docker image
      working-directory: ./initial
      run: |
        docker build -t $ECR_REPOSITORY:$IMAGE_TAG .

    - name: Tag Docker image
      run: |
        docker tag $ECR_REPOSITORY:$IMAGE_TAG ${{ steps.login-ecr.outputs.registry }}/$ECR_REPOSITORY:$IMAGE_TAG

    - name: Push Docker image to ECR
      run: |
        docker push ${{ steps.login-ecr.outputs.registry }}/$ECR_REPOSITORY:$IMAGE_TAG

    - name: Install Cosign
      uses: sigstore/cosign-installer@v3.3.0
      with:
        cosign-release: 'v2.2.2'

    # - name: Sign Docker image with Cosign
    #   env:
    #     COSIGN_EXPERIMENTAL: "1"
    #     COSIGN_PASSWORD: ${{ secrets.COSIGN_PASSWORD }}
    #     COSIGN_KEY: ${{ secrets.COSIGN_KEY }}
    #   run: |
    #     IMAGE="${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ env.IMAGE_TAG }}"
    #     echo "$COSIGN_KEY" > cosign.key
    #     cosign sign --key cosign.key $IMAGE

    - name: Update kubeconfig for EKS
      run: |
        aws eks update-kubeconfig --region $AWS_REGION --name ${{ secrets.EKS_CLUSTER_NAME }}

    - name: Create ConfigMap for SQL
      working-directory: ./initial
      run: |
        kubectl create configmap init-sql-script --from-file=src/main/resources/schema.sql --dry-run=client -o yaml | kubectl apply -f -
        
    - name: Apply MySQL ConfigMap, Secret, and Deployment
      working-directory: ./initial
      run: |
        kubectl apply -f mysql-configmap.yaml
        kubectl apply -f secrets.yaml
        kubectl apply -f mysql-deployment.yaml

    - name: Wait for MySQL readiness
      run: |
        echo "Waiting for MySQL pod..."
        kubectl wait --for=condition=ready pod -l app=demo-app --timeout=120s

    - name: Install Helm
      run: |
        curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash
        helm version

    - name: Add Kyverno Helm repo
      run: helm repo add kyverno https://kyverno.github.io/kyverno/

    - name: Update Helm repos
      run: helm repo update

    - name: Install or upgrade Kyverno with Helm
      run: |
        helm upgrade --install kyverno kyverno/kyverno \
          --namespace kyverno --create-namespace

    # - name: Check and Install Kyverno
    #   run: |
    #     if kubectl wait --for=condition=ready pod -l app.kubernetes.io/part-of=kyverno --namespace kyverno --timeout=30s; then
    #       echo "Kyverno already installed."
    #     else
    #       echo "Installing Kyverno..."
    #       kubectl apply -f https://github.com/kyverno/kyverno/releases/download/v1.11.1/install.yaml
    #     fi

    # - name: Install Kyverno via kubectl
    #   # uses: kyverno/action-install-cli@v0.2.0
    #   # with:
    #   #   release: 'v1.9.5'
    #   #   verfy: true
    #   run: |
    #     kubectl create -f https://github.com/kyverno/kyverno/releases/download/v1.11.1/install.yaml
    
    - name: Wait for Kyverno to be ready
      run: |
        echo "Waiting for Kyverno pods to be ready..."
        kubectl wait --for=condition=ready pod -l app.kubernetes.io/part-of=kyverno --namespace kyverno --timeout=120s

    - name: Apply Cosign public key ConfigMap
      working-directory: ./initial
      run: |
        kubectl apply -f kyverno-configmap.yaml

    - name: Apply Kyverno verify-image policy
      working-directory: ./initial
      run: |
        kubectl apply -f kyverno-policy.yaml

    - name: Delete existing job if it exists
      run: |
        kubectl delete job batch-job --ignore-not-found

    - name: Inject image into CronJob manifest
      working-directory: ./initial
      run: |
        export IMAGE="${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ env.IMAGE_TAG }}"
        envsubst < app-deployment.yaml > final-cronjob.yaml

    - name: Apply CronJob to EKS
      working-directory: ./initial
      run: |
        kubectl apply -f final-cronjob.yaml











        
    # - name: Delete existing job if it exists
    #   run: |
    #     kubectl delete job batch-job --ignore-not-found
    
    # - name: Apply batch Job to EKS
    #   working-directory: ./initial
    #   run: |
    #     kubectl apply -f batch-job.yaml
      
    # - name: Deploy Spring Batch App
    #   working-directory: ./initial
    #   run: |
    #     kubectl apply -f app-deployment.yaml

    # - name: Set image for batch-app
    #   working-directory: ./initial
    #   run: |
    #     kubectl set image deployment/batch-app batch-app=${{ steps.login-ecr.outputs.registry }}/$ECR_REPOSITORY:$IMAGE_TAG

    # - name: Deploy to EKS
    #   run: |
    #     kubectl set image deployment/batch-app batch-app=${{ steps.login-ecr.outputs.registry }}/$ECR_REPOSITORY:$IMAGE_TAG

    # - name: Publish to GitHub Packages Apache Maven
    #   run: mvn deploy -s $GITHUB_WORKSPACE/settings.xml
    #   env:
    #     GITHUB_TOKEN: ${{ github.token }}
