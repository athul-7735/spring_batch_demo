name: CICD
on: push
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up JDK 11
      uses: actions/setup-java@v4
      with:
        java-version: '17'
        distribution: 'temurin'

    - name: Cache Maven dependencies
      uses: actions/cache@v4
      with:
        path: ~/.m2/repository
        key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
        restore-keys: |
          ${{ runner.os }}-maven-
          
    - name: Build with Maven
      working-directory: ./initial
      run: mvn --batch-mode clean test package

    - name: Upload build artifact
      uses: actions/upload-artifact@v4
      with:
       name: app-jar
       path: initial/target/*.jar
  
  deploy:
    needs: build
    runs-on: ubuntu-latest
    
    env:
      AWS_REGION: ${{ secrets.AWS_REGION }}
      ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
      IMAGE_TAG: ${{ github.sha }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Download JAR artifact
      uses: actions/download-artifact@v4
      with:
        name: app-jar
        path: initial/target
        
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-region: ${{ env.AWS_REGION }}
        role-to-assume: arn:aws:iam::557690581666:role/GitHubActionsEKSRole
        role-session-name: GitHubActions
        audience: sts.amazonaws.com

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v1

    - name: Build Docker image
      working-directory: ./initial
      run: |
        docker build -t $ECR_REPOSITORY:$IMAGE_TAG .

    - name: Tag Docker image
      run: |
        docker tag $ECR_REPOSITORY:$IMAGE_TAG ${{ steps.login-ecr.outputs.registry }}/$ECR_REPOSITORY:$IMAGE_TAG

    - name: Push Docker image to ECR
      run: |
        docker push ${{ steps.login-ecr.outputs.registry }}/$ECR_REPOSITORY:$IMAGE_TAG

    - name: Install Cosign
      uses: sigstore/cosign-installer@v3.1.1
      with:
        cosign-release: 'v2.2.3'

    - name: Sign Docker image with Cosign
      env:
        COSIGN_EXPERIMENTAL: "1"
        COSIGN_PASSWORD: ${{ secrets.COSIGN_PASSWORD }}
        COSIGN_KEY: ${{ secrets.COSIGN_KEY }}
      run: |
        IMAGE="${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ env.IMAGE_TAG }}"
        echo "$COSIGN_KEY" > cosign.key
        cosign sign --key cosign.key $IMAGE

    - name: Update kubeconfig for EKS
      run: |
        aws eks update-kubeconfig --region $AWS_REGION --name ${{ secrets.EKS_CLUSTER_NAME }}

    - name: Create ConfigMap for SQL
      working-directory: ./initial
      run: |
        kubectl create configmap init-sql-script --from-file=src/main/resources/schema.sql --dry-run=client -o yaml | kubectl apply -f -
        
    - name: Apply MySQL ConfigMap, Secret, and Deployment
      working-directory: ./initial
      run: |
        kubectl apply -f mysql-configmap.yaml
        kubectl apply -f secrets.yaml
        kubectl apply -f mysql-deployment.yaml

    - name: Wait for MySQL readiness
      run: |
        echo "Waiting for MySQL pod..."
        kubectl wait --for=condition=ready pod -l app=demo-app --timeout=120s
        
    # - name: Inject image into Job manifest
    #   working-directory: ./initial
    #   run: |
    #     export IMAGE="${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ env.IMAGE_TAG }}"
    #     envsubst < app-deployment.yaml > batch-job.yaml
    
    - name: Install Kyverno via kubectl
      run: |
        kubectl apply -f https://raw.githubusercontent.com/kyverno/kyverno/main/definitions/release/install.yaml

    - name: Apply Cosign public key ConfigMap
      working-directory: ./initial
      run: |
        kubectl apply -f kyverno-configmap.yaml

    - name: Apply Kyverno verify-image policy
      working-directory: ./initial
      run: |
        kubectl apply -f verify-image-policy.yaml

    - name: Delete existing job if it exists
      run: |
        kubectl delete job batch-job --ignore-not-found

    - name: Inject image into CronJob manifest
      working-directory: ./initial
      run: |
        export IMAGE="${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ env.IMAGE_TAG }}"
        envsubst < app-deployment.yaml > final-cronjob.yaml

    - name: Apply CronJob to EKS
      working-directory: ./initial
      run: |
        kubectl apply -f final-cronjob.yaml











        
    # - name: Delete existing job if it exists
    #   run: |
    #     kubectl delete job batch-job --ignore-not-found
    
    # - name: Apply batch Job to EKS
    #   working-directory: ./initial
    #   run: |
    #     kubectl apply -f batch-job.yaml
      
    # - name: Deploy Spring Batch App
    #   working-directory: ./initial
    #   run: |
    #     kubectl apply -f app-deployment.yaml

    # - name: Set image for batch-app
    #   working-directory: ./initial
    #   run: |
    #     kubectl set image deployment/batch-app batch-app=${{ steps.login-ecr.outputs.registry }}/$ECR_REPOSITORY:$IMAGE_TAG

    # - name: Deploy to EKS
    #   run: |
    #     kubectl set image deployment/batch-app batch-app=${{ steps.login-ecr.outputs.registry }}/$ECR_REPOSITORY:$IMAGE_TAG

    # - name: Publish to GitHub Packages Apache Maven
    #   run: mvn deploy -s $GITHUB_WORKSPACE/settings.xml
    #   env:
    #     GITHUB_TOKEN: ${{ github.token }}
